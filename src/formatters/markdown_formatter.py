"""Markdown formatter for daily reports."""

from datetime import datetime
from typing import Dict, List
from collections import defaultdict
from jinja2 import Template
from src.models.analysis import AnalysisResult, CategoryType
from src.models.report import DailyReport


class MarkdownFormatter:
    """Formats analysis results into markdown reports."""

    # Category emojis
    CATEGORY_EMOJIS = {
        "Breaking News": "ğŸ”¥",
        "Research": "ğŸ”¬",
        "Tools/Products": "ğŸ› ï¸",
        "Business": "ğŸ’¼",
        "Tutorial": "ğŸ“š",
    }

    CATEGORY_NAMES_CN = {
        "Breaking News": "é‡å¤§æ–°è",
        "Research": "å­¸è¡“ç ”ç©¶",
        "Tools/Products": "å·¥å…·èˆ‡ç”¢å“",
        "Business": "å•†æ¥­å‹•æ…‹",
        "Tutorial": "æŠ€è¡“æ•™ç¨‹",
    }

    TEMPLATE = """ğŸ“± *AI News Brief*
ğŸ“… {{ push_time }}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š ä»Šæ—¥å…±æ”¶éŒ„ *{{ total_articles }}* å‰‡è³‡è¨Š
â­ å¹³å‡é‡è¦æ€§è©•åˆ†: *{{ average_importance }}/10*

{% for category, articles in articles_by_category.items() %}
{% if articles %}
*{{ category_emoji[category] }} {{ category_names[category] }}* ({{ articles|length }}å‰‡)
{% for analysis in articles %}
{{ importance_icon(analysis.importance_score) }} *{{ escape(analysis.title_cn) }}*
   [{{ escape(analysis.article.source) }}]({{ analysis.article.url }})
   ğŸ’¡ {{ escape(analysis.summary) }}
   âœ¨ _{{ escape(analysis.insight) }}_

{% endfor %}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
{% endif %}
{% endfor %}
_ğŸ¤– Auto-generated by AI News Brief_
"""

    def __init__(self):
        """Initialize markdown formatter."""
        self.template = Template(self.TEMPLATE)

    @staticmethod
    def _escape_markdown(text: str) -> str:
        """Escape markdown special characters.

        Args:
            text: Text to escape

        Returns:
            Escaped text
        """
        if not text:
            return ""
        # Escape characters that have special meaning in Markdown
        chars_to_escape = ["_", "*", "`", "["]
        for char in chars_to_escape:
            text = text.replace(char, f"\\{char}")
        return text

    @staticmethod
    def _importance_stars(score: int) -> str:
        """Convert importance score to star rating.

        Args:
            score: Importance score (0-10)

        Returns:
            Star rating string (e.g., "â­â­â­")
        """
        if score >= 9:
            star_count = 5
        elif score >= 7:
            star_count = 4
        elif score >= 5:
            star_count = 3
        elif score >= 3:
            star_count = 2
        else:
            star_count = 1
        return "â­" * star_count

    @staticmethod
    def _importance_icon(score: int) -> str:
        """Convert importance score to color icon.

        Args:
            score: Importance score (0-10)

        Returns:
            Color icon indicating importance level
        """
        if score >= 8:
            return "ğŸ”´"  # High importance
        elif score >= 6:
            return "ğŸŸ¡"  # Medium importance
        else:
            return "ğŸŸ¢"  # Normal importance

    def format(self, date: datetime, analyzed_articles: List[AnalysisResult]) -> DailyReport:
        """Format analyzed articles into a daily report.

        Args:
            date: Report date
            analyzed_articles: List of analyzed articles

        Returns:
            DailyReport object
        """
        # Group articles by category and sort by importance
        articles_by_category = self._group_by_category(analyzed_articles)

        # Calculate statistics
        total_articles = len(analyzed_articles)
        average_importance = (
            sum(a.importance_score for a in analyzed_articles) / total_articles
            if total_articles > 0
            else 0
        )

        # Generate markdown
        push_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        markdown_content = self.template.render(
            date=date.strftime("%Y-%m-%d"),
            push_time=push_time,
            total_articles=total_articles,
            average_importance=f"{average_importance:.1f}",
            articles_by_category=articles_by_category,
            category_emoji=self.CATEGORY_EMOJIS,
            category_names=self.CATEGORY_NAMES_CN,
            format_time=self._format_relative_time,
            importance_stars=self._importance_stars,
            importance_icon=self._importance_icon,
            escape=self._escape_markdown,
            generation_time=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        )

        return DailyReport(
            date=date,
            articles_by_category=articles_by_category,
            markdown_content=markdown_content,
            total_articles=total_articles,
            average_importance=average_importance,
        )

    def _group_by_category(
        self, articles: List[AnalysisResult]
    ) -> Dict[CategoryType, List[AnalysisResult]]:
        """Group articles by category and sort by importance.

        Args:
            articles: List of analyzed articles

        Returns:
            Dict mapping category to sorted list of articles
        """
        grouped: Dict[CategoryType, List[AnalysisResult]] = defaultdict(list)

        for article in articles:
            grouped[article.category].append(article)

        # Sort each category by importance score (descending)
        for category in grouped:
            grouped[category].sort(key=lambda x: x.importance_score, reverse=True)

        # Return in desired order
        ordered_categories = ["Breaking News", "Research", "Tools/Products", "Business", "Tutorial"]
        return {cat: grouped[cat] for cat in ordered_categories if cat in grouped}

    def _format_relative_time(self, dt: datetime) -> str:
        """Format datetime as relative time string.

        Args:
            dt: Datetime to format

        Returns:
            Relative time string (e.g., "2å°æ™‚å‰")
        """
        now = datetime.now()
        if dt.tzinfo is not None:
            dt = dt.replace(tzinfo=None)

        delta = now - dt
        days = delta.days
        hours = delta.seconds // 3600
        minutes = delta.seconds // 60

        if days > 0:
            return f"{days}å¤©å‰"
        if hours > 0:
            return f"{hours}å°æ™‚å‰"
        if minutes > 0:
            return f"{minutes}åˆ†é˜å‰"
        return "å‰›å‰›"
